# PRD: Потеря данных после перезагрузки страницы

Дата: 2026-01-17  
Статус: Draft  
Владелец: Product Owner / Tech Lead

## Контекст и проблема
После перезагрузки страницы сохраненные данные (history, readinessLogs, achievements, weights) пропадают из UI. В логах видно, что запросы записи в backend проходят успешно, но последующий `GET /data/sync` возвращает пустые массивы. Это вызывает потерю прогресса и снижает доверие к продукту.

### Симптомы (из логов)
- `POST /data/readinessLogs`, `POST /data/history`, `POST /data/achievements` → `{success: true}`
- После обновления: `GET /data/sync` → `{ history: [], painLogs: [], achievements: [], readinessLogs: [], weights: {} }`

## Диагностика (что уже известно)
- Фронтенд не делает автоматическую запись пустых массивов при перезагрузке.
- Потеря происходит при чтении: сервер возвращает пустой набор, хотя ранее записи фиксировались.
- Значит, запись уходит в другое место (другой ключ пользователя/БД/окружение) либо чтение происходит по несовпадающему ключу.

## Гипотезы корневой причины
1. Несовпадение ключа пользователя между записью и чтением:
   - `userId` в JWT отличается от ключа в таблице `userData`.
   - Ранее данные могли сохраняться под email (legacy-ключ), теперь читаем только по `userId`.
2. Разные окружения/конфигурации для auth и data:
   - Разные переменные `YDB_ENDPOINT`/`YDB_DATABASE` у маршрутов `GET /data/sync` и `POST /data/*`.
3. Неполная валидация успешности записи:
   - Сервер отвечает `{success: true}` без подтверждения, что запись действительно закрепилась.

## Цели
- Гарантировать, что данные, записанные после тренировки, доступны после перезагрузки.
- Восстановить данные пользователей, которые сохранялись по legacy-ключам.
- Добавить прозрачность и диагностику синхронизации.

## Не-цели
- Изменение схемы YDB (`userData` остается прежней).
- Изменения в авторизации/регистрации.
- Полный редизайн UI.

## Решение (MVP)

### 1) Единый канонический ключ пользователя
- Использовать `userId` из таблицы `users` как единственный ключ для `userData`.
- На чтении:
  - Если данных по `userId` нет — искать по legacy-ключу (email из `users`/JWT).
  - "Пусто" определяется по каждому типу (пустой массив/объект) и отсутствию `lastUpdatedAt` в meta.
  - При наличии legacy-данных мигрировать их к `userId` (on-read), только если `primary` пуст.
  - Если email мог измениться и legacy-ключ не найден — логировать событие `legacy_key_not_found` и показывать баннер с подсказкой обратиться в поддержку.
- На записи:
  - Всегда писать только под `userId`.
  - Возвращать ошибку, если запись не подтверждена чтением (read-after-write).

### 2) Явная проверка записи, консистентность и метаданные синхронизации
- При `POST /data/:type`:
  - Выполнять запись и делать read-after-write по `userId`.
  - Возвращать `type`, `savedAt`, `payloadSize`, `itemCount` (для массивов), `checksum` (простая hash строкового payload).
  - При несовпадении `checksum` или `itemCount` возвращать ошибку и логировать `write_mismatch`.
- При `GET /data/sync` возвращать:
  - `meta` с `lastUpdatedAt`, `source` (`primary`/`legacy`) и `checksum` для каждого типа.
- Миграция legacy:
  - Писать в `primary` только если он пуст и legacy не пуст.
  - Оставлять legacy-строку как резервную копию до отдельного ручного удаления.
  - Повторная миграция должна быть идемпотентной.
- Логи сервера: `userId`, `emailHash` (маскировать/хешировать), `type`, `payloadSize`, `rowsRead`, `source`, `env` (endpoint/db).

### 3) Клиентская страховка от «тишины»
- Сохранять последний успешный snapshot данных в localStorage (`mfr_last_sync`).
- Если `GET /data/sync` вернул пусто, но локальный snapshot не пуст:
  - показать баннер “Данные не найдены на сервере. Восстановить локальную копию?”
  - при подтверждении — восстановить локально и отправить на сервер с флагом `restoreFromSnapshot`.
- Если `meta.lastUpdatedAt` на сервере новее локального snapshot, запретить восстановление и показать причину.
- Не восстанавливать автоматически без явного подтверждения.
- Показать пользователю `lastSyncedAt` из локального snapshot, чтобы снизить риск восстановления устаревшего состояния.

### 4) Тесты и мониторинг
- Backend:
  - `POST /data/:type` → `GET /data/sync` возвращает сохраненные данные.
  - Fallback по legacy-ключу + миграция.
  - Метаданные синхронизации присутствуют.
  - Несовпадение `checksum`/`itemCount` приводит к ошибке.
- Frontend:
  - Пустой ответ `GET /data/sync` + snapshot → показывается восстановление.
  - Отказ от восстановления не приводит к автоматическому перезаписи.
  - Серверные данные новее локальных → восстановление заблокировано.
- Аналитика:
  - `sync_empty_after_write` (context: userId, hasLocalSnapshot, typesMissing).
  - `legacy_key_not_found`, `write_mismatch`, `restore_blocked_newer_server`.

## Acceptance Criteria
- Данные, записанные через `POST /data/:type`, гарантированно доступны через `GET /data/sync` после перезагрузки.
- Пользователь с legacy-данными получает свои записи после первого `GET /data/sync`.
- В случае пустого ответа сервера при наличии локального snapshot пользователь получает явный выбор восстановления.
- Восстановление из snapshot не перезаписывает более свежие серверные данные.
- Логи и meta позволяют диагностировать источник данных (`primary` vs `legacy`), дату обновления и ошибки записи.
- Автотесты покрывают сценарии записи/чтения и legacy-миграции.

## План валидации
1. Создать тренировку → сохранить `history`, `readinessLogs`, `achievements`.
2. Обновить страницу → данные отображаются.
3. Смоделировать legacy-данные (по email) → после `GET /data/sync` данные мигрируют к `userId`.
4. Принудительно вернуть пустой ответ (mock) → появляется баннер восстановления.
5. Серверные данные новее локальных → баннер объясняет, почему восстановление недоступно.

## Риски и меры
- Риск дублирования данных при миграции → миграция только если `primary` пуст и `legacy` не пуст; идемпотентная запись.
- Риск возврата устаревшей локальной копии → UI подтверждение, проверка `lastUpdatedAt`, отображение `lastSyncedAt`.
- Риск разных окружений → добавить лог окружения (endpoint/db) при старте функции.
- Риск утечки PII в логах → хешировать email и не писать полный адрес.

## Чек-лист прогресса
Формат: [ ] не начато, [~] в работе, [x] готово.
- [x] Подтвердить корневую причину (ключ пользователя / окружение).
  - **Выявлено**: Race condition в read-after-write проверке из-за использования разных сессий YDB.
- [x] Исправить write_mismatch race condition (atomic write+read в одной сессии).
- [x] Реализовать fallback + миграцию legacy-данных.
- [x] Добавить meta и подробные логи синхронизации.
- [x] Добавить клиентский recovery banner.
- [x] Добавить тесты (backend + frontend).
- [x] Добавить аналитическое событие `sync_empty_after_write`.

